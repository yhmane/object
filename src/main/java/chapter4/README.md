# 설계 품질과 트레이드오프 (chapter4)
---
> 객체지향 설계
>
> “올바른 객체에게 올바른 책임을 할당하면서
> 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다”

* 객체가 가지는 데이터보다 책임에 초점을 맞추어 설계를 하자
    * 퍼블릭 인터페이스를 제공하여 객체의 자유도를 높이자
    * 메세지를 통해 상호작용하여 결합도 낮은 설계를 하자

## 설계 트레이드오프
“객체를 캡슐화하여 내부 구현을 감추고,
결합도는 낮고 응집도는 높은
프로그램 설계를 지향하라”

### 캡슐화
> 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
* 객체 내부에 무엇을 캡슐화 해야 하는가?
    * 변경될 수 있는 어떤 대상이라도 캡슐화 해야 한다!


### 응집도
> 모듈 내부에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다
모듈 내의 요소들이 하나의 목적을 위해 협력한다면 높은 응집도를 가진다.
서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.
객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 있는 책임을 할당했는지를 나타낸다.

[image:889EB71F-9DCC-4D6B-8013-E74D66CD628D-819-0000036B2919C07F/3E43287D-7DE4-48A0-85D6-2A6EBAB07B0A.png]
* * 응집도 변경의 관점에서 - 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도*
    응집도가 높을 경우 변경이 발생하면, 오직 하나의 모듈만 수정하면 된다. 반면, 응집도가 낮을 경우 변경이 발생하면 여로 모듈을 수정하게 된다.

### 결합도
> 의존성의 정도를 나타낸다. 다른 모듈에 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다.
객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다
[image:AC79A552-5F1C-44DD-94C7-4301D0B11499-819-00000372068ECB95/75B95241-494A-4797-8636-B7DF82B729D4.png]
* * 결합도 변경의 관점에서 - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도*
    결합도가 낮을 경우 수정해야 하는 모듈이 적지만, 결합도가 높을 경우 변경이 발생하게 되면 다른 모듈까지 같이 수정하게 된다.

---
## 데이터 중심 설계의 문제점


### 캡슐화 위반
* 오직 메서드만을 통해 내부 상태에 접근한다. 어떠한 점이 캡슐화를 위반한 것일까?
```java
public class Movie {
    private Money fee;
    
    public Money getFee() {
        return fee;
    }

    public void setFee(Money fee) {
        this.fee = fee;
    }
}
```
* 접근자와 수정자를 통해 Money타입의 fee라는 상태가 존재한다는 것을 알 수 있다
    * 캡슐화를 위반하는 이유는 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다
### 높은 결합도
```java
public class ReservationAgency {      
   ...
	if (discountable) {
		fee = movie.getFee().minus(discountAmount).times(audienceCount);
	} else {
	fee = movie.getFee().times(audienceCount);
	}
  ...
}

```

* Movie의 fee는 private한 상태이지만, 구현 로직을 보면 전혀 private하지 않다.
  [image:6CADDC20-2ACF-48C8-BA3E-046742361318-819-00000580969A3DF1/B6DD19CB-225E-43EA-9626-356B52367824.png]
  결국 데이터 중심의 설계로, ReservationAgency는 높은 결합도를 가지게 되었다. 따라서, 이 모듈을 변경하게 되면 다른 모듈까지 많은 변경을 요구하게 된다.

###  낮은 응집도
ReservationAgency에는 할인 가격을 계산한다는 이유로 변경 이유가 서로 다른 코드를 전부 뭉쳐놓는다. 따라서 하나의 요구사항을 반영하기 위해서는 여러 모듈을 수정해야한다. 응집도가 낮은것이다.

### 자율적인 객체
접근자, 수정자를 통해 객체의 내부상태에 접근을 허용하였다
-> get/set 메서드를 제거하고 클래스 내부에서 책임를 지도록 변경하자


### 데이터 중심 설계의 문제점
* 너무 이른시기에 데이터에 관해 결정하도록 강요한다
* 협력이라는 문맥을 고려하지 않고 객체를 고립시킨채 operation을 결정한다.

