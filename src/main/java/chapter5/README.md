# 책임 할당하기 (chapter5)
---
## 책임 주도 설계를 향해
* 데이터보다 행동을 먼저 결정
* 협력이라는 문맥 안에서 책임을 결정

> 데이터보다 행동을 먼저 결정하라
>
> “객체지향에 갓 입문한 사람들이 가장 많이 저지르는 실수는
> 객체의 행동이 아닌 데이터에 초점을 맞추는 것”

* 데이터 중심 설계
    * 객체가 포함해야 하는 데이터를 먼저 선정
    * 그 후, 데이터를 처리하는 데 필요한 행동을 구현
* 책임 중심 설계
    * 객체가 수행할 책임을 먼저 정의
    * 그 후, 책임을 처리하는 데 필요한 데이터를 정의

### “객체의 데이터 중심 설계 ->  책임 중심 설계”로 설계 방식을 바꿔야 한다

> 협력이라는 문맥 안에서 책임을 결정하라
>
> “책임은 객체의 입장이 아니라,
> 객체가 참여하는 협력에 적합해야 한다”

* 협력에 적합한 책임을 할당하기
    * 먼저, 수행할 메세지를 정의
    * 메시지를 수행할 객체를 선택
    * 즉, 객체가 메시지를 선택하는 게 아니라, 메시지가 객체를 선택하도록 설계

### “클래스가 필요하다는 것은 알겠는데, 이 클래스는 무엇을 해야 하지?” ->“메시지를 전송해야 하는데 누구 에게 전송하지?”
#### 관점을 바꾸어 설계

---
## 책임 할당을 위한 GRASP 패턴
> 크레이그 라만
>
> “GRASP - General Responsibility Assignment Software Pattern”
> 일반적인 책임 할당을 위한 소프트웨어 패턴의 약자로
> 책임 할당시 지침으로 삼을 수 있는 원칙들의 집합

### 도메인 개념에서 출발

[image:7AA327F2-E6B7-4743-8830-D3D134C26738-6093-000003ABB1B856E2/95F12ADD-6E20-426E-875A-A93C70366E5E.png]

* 설계를 시작하기 전 도메인에 대한 개략적인 모습을 그려보자
    * 도메인 개념들을 책임 할당의 대상으로 사용하면 코드의 투영하기 수월해진다

### 정보 전문가에게 책임을 할당
[image:BFC1FB11-7681-4834-A9A9-77FF302C6991-6093-000003FD6FCE79EC/DC1998E4-EBEE-4FAA-A642-9443F0050DB6.png]

* “정보전문가 패턴”
    * 책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 할당하라
* 메시지를 먼저 정의하고, 그 메시지를 수행할 객체를 선정하라
    * 그 정보를 *가장 잘 아는* 객체를 선정하고 책임을 할당하라

### 높은 응집도와 낮은 결합도 (chapter4)
* 응집도 (Cohesion)
    * 모듈에 포함된 내부 요소들이 하나의 책임/ 목적을 위해 연결되어있는 연관된 정도
* 결합도
    * 다른 모듈과의 의존성이 정도

### 창조자에게 객체 생성 책임을 할당
> CREATOR 패턴
> “객체 A를 생성해야 할때, 그 객체를 가장 잘 아는
> 객체 B에게 객체 생성 책임을 할당하라”

* B가 A 객체를 포함하거나 참조
* B가 A 객체를 기록
* B가 A 객체를 긴밀하게 사용
* B가 A 객체를 초기화하는데 필요한 데이터 정보를 포함 (B가 A의 정보 전문가)

---

## 구현을 통한 검증
* 변경에 취약

```java
public class DiscountCondition {

  public boolean isSatisfiedBy(Screening screening) {
     if (type == DiscountConditionType.PERIOD) {
        return isSatisfiedByPeriod(screening);
     }
     return isSatisfiedBySequence(screening);
  }

  private boolean isSatisfiedByPeriod(Screening screening) {
		...
  }

  private boolean isSatisfiedBySequence(Screening screening) {
		...
	}
```

* 새로운 할인 조건 추가
* 순번 조건 로직의 변경
* 기간 조건 로직의 변경
> 해당 클래스는 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다.
> 응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 뭉쳐 있다는 것을 의미한다

---
## 책임 주도 설계의 대안
> 클래스는 오직 하나의 작업만 수행하고,
> 하나의 변경 이유만 가지는 작고 명확하고
> 응집도 높은 메서드들로 구성되어야 한다.

### 몬스터 메서드
* 어떤 일을 수행하는지 한눈에 파악하기 어렵다
* 하나의 메서드 안에 너무 많은 작업을 처리한다
* 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다
* 로직의 일부만 재사용하는 것이 불가능 하다

### 변경과 유연성 - 개발자로서 변경에 대비하는 방법
* 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계
* 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 유연하게 작성

책임주도 설계 방법이 익숙하지 않다면 일단 데이터 중심으로 구현한 뒤 이를 리펙터링을 통해 유사한 결과를 얻을 수 있다는 점이다. 아직, 책임 주도 설계가 익숙하지 않다면 동작하는 코드를 작성후 리팩토링을 하는 것도 좋은 대안이 될 수 있다
