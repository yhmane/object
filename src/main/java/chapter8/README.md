# 8장 의존성 관리하기
잘 설계된 객체지향 애플리케이션
* 작고 응집도 높은 객체들로 구성
* 책임의 초점이 명확하고 한 가이 일을 잘 수행
* 이러한 객체들이 모여 협력을 함

협력을 위해서는 의존성이 필요하지만 과도한 협력은 의존성의 문제로 애플리케이션의 변경을 힘들게 한다

이러한 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일수 있는 의존성을 정리하는 기술이라고 할 수 있다

자, 그럼 먼저 의존성을 알아보자
---
## 의존성 이해하기
### 변경과 의존성
객체가 협력하기 위해 다른 객체를 필요로 할때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 실행시점과 구현 시점에 따라 서로 다른 의미를 갖는다

* 실행시점
    * 의존하는 객체가 정상적으로 동작하기 위해 실행시에 의존 대상 객체가 존재해야함
* 구현 시점
    * 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다

[image:343786E8-1E41-43AD-B9C1-69989A58ADA0-879-000009F509C3E523/2B60A160-AE4A-46C7-AD81-0ADC8D6867F5.png]

위의 코드를 해당 시점에 경우로 나누어 살펴보자
1. 구현 시점
   isSatisfiedBy() 내부는 DayOfWeek, Screening, LocalTime, DiscountCondition에 영향을 받는다. 따라서 해당 클래스나 변수가 변경이 생기게 된다면 PeriodCondition에게 당연히 영향을 끼친다
2. 실행시점
   isSatisfiedBy() 실행시 Screening 인스턴스가 존재해야 한다. 그렇지 않다면 해당 내부의 로직 수행중에 에러가 날 것이다

따라서, 두 요소 사이의 의존성은 의존되는 요소가 변경 될때 의존하는 요소도 함께 변경될 수 있음을 의미한다

### 의존성 전이
Screeing의 내부 코드는 Movie, LocalDateTime, Customer에 의존한다는 것을 알 수 있다.

[image:35EBCFF5-726F-4867-B013-47052DD80D74-879-00000A72432C7E84/CC3D5EA8-3FF5-41D1-ABE0-2C01DA412F81.png]
```
PeriodCondition -> Screening (직접 의존)
Screening -> Movie (직접 의존)

PeriodCondition ---> Movie (간접 의존)
```

위의 그림을 잠깐 살펴보자.
PeriodCondition은 Screening에, Screeing은 Movie에 의존하고 있다.
이렇듯 객체가 다른 객체에 의존하고 있을 경우 ‘직접 의존한다’라고 한다

다만, PeriodCondition은 Movie에 직접 의존하지 않고, 코드상에 드러나지는 않지만 이러한 연결고리가 잠재적으로 영향을 미칠 수 있다. 이렇듯, 직접 연관되지 않지만 연관된 객체에 의존된 관계가 맺어질 경우 ‘간접 의존한다’라고 한다

### 런타임 의존성과 컴파일타임 의존성
의존성과 관련해서 또 다뤄야 할 부분은 런타임의존성과 컴파일 의존성이다

* 런타임 의존성
    * 말그대로 애플리케이션이 실행되는 시점
* 컴파일 의존성
    * 컴파일 시점에 작성된 코드가 문맥에 따라 의존하는 관계

아래의 예제를 살펴보자

[image:E1370F7B-10E8-4CBF-8E0D-73EC1379280A-879-00000D023F84CF52/B8819351-F6E9-4A8D-8D0B-8110C80A22AE.png]

[image:6937C8FB-BFFF-4857-B0F0-7ED5CD931058-879-00000CF5700A3089/A087EAAE-ABF6-4770-B47E-C5F0EEB12B0C.png]
코드상에서 Movie는 DiscountPolicy에 의존하고 있다. 어느 부분에도 AmountDiscountPolicy, PercentDiscountPolicy에 의존하는지 명시되어 있지 않다.

클래스가 어떠한 인스턴스 타입과 협력하는지 코드상에서 알 수 없게 되면 코드의 재사용이 가능해지고 다양한 협력관계를 가질 수 있는 장점이 있다.

이렇듯 런타임 의존성과 컴파일 의존성은 서로 다를 수 있다. 이러한 다름 때문에 프로그래머는 유연하고 재사용 가능한 코드를 설계할 수 가 있다

### 컨텍스트 독립성
클래스가 구체적인 클래스를 알게 될수록, 그 클래스가 사용하는 문맥에 강하게 결합된다
따라서, 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄진다면
다른 문맥에서 재사용하기가 더 수월해진다. 이를 *컨텍스트 독립성*이라고 부른다

결국 의존하는 관계에서는 실행될 컨텍스트에 대한 구체적 정보를 최대한 적게 알도록 설계해야 한다

### 의존성 해결하기
결국 컴파일 타임 의존성이 구체적인 런타임 의존성으로 대체되어야 재사용 가능한 코드가 작성될 수 있다. 이처럼 컴파일타임 의존성을 실행 컨텍스에 맞는 런타임 의존성으로 교체하는 것을 *의존성 해결*이라고 부른다

의존성을 해결하기 위해서는 다음과 같은 세 가지 방법을 사용한다
1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
   생성자를 통해 주입하여 준다
   [image:2520000B-82AF-4486-9FB1-1D09AEB269A0-879-00000FEA24E6BF66/FE64A168-BF81-4788-971C-02D14486AD3C.png]

2. 객체를 생성후 setter 메서드를 통해 의존성 해결
   [image:46CB6CEC-9710-43AF-89B7-F6F55CBDE239-879-00000FF56406C49C/F1592F0F-6263-4377-9B2B-5E2623C309D8.png]
* set method를 구현해주어야 한다
* set을 하기 전까지 객체가 불안정하여 NullPointerException이 발생할 수 있다
3. 메서드 실행 시 인자를 이용해 의존성 해결

[image:2F1723B2-92B5-404F-A011-81FB425B1EA0-13299-00000F8CBBD50AA1/A3596011-884F-4DB8-8F48-14071EE251CA.png]
[image:804C2169-ABCD-4CDC-9DBE-35F394D6112E-879-00000FF1475129F9/47259EA9-8577-4313-BB27-C6B62EF0DD62.png]
가장 좋은 방법은 생성자와 수정자를 같이 이용하는 것이다. 시스템의 안전성을 보장해주고 필요에 따라 의존성을 변경할 수 있기 때문에 유연성을 향상시킬 수 있다

---
## 유연한 설계
설계를 유연하고 재사용 가능하게 만들기로 결정했다면 의존성을 관리하는데 유용한 몇가지 원칙을 익힐 필요가 있다. 먼저 의존성과 결합도의 관계를 살표보자

### 의존성과 결합도
객체지향 패러다임의 근간은 협력이다.
객체들은 협력하기 위해 서로의 존재와 수행 가능한 책임을 알아야 한다. 이러한 지식들이 객체 사이의 의존성을 낳는다. 따라서 의존성이 꼭 나쁜것은 아니다. 의존성은 객체들의 협력을 가능케 하는 매개체이고 바람직한 것이다. 다만, 과하면 문제가 될 수 있다.

다음 코드를 살펴보자
[image:6E07B46D-52CC-4616-8722-83F2830EB368-879-000010A447ECEA19/7DA0C0E7-E8AD-4DE3-909A-9C1811EE186E.png]

Movie는 PercentDiscountPolicy에 의존한다. 의존한다는 사실 자체는 바람직한 관계이다. 다만, Movie가 PercentDiscountPolicy라는 구체적 클래스에 의존하기 때문에 다른 할인 정책을 문맥에서 사용하기 힘들어졌다.

바람직한 의존성이란 무엇인가? 바람직한 의존성은 재사용과 관련이 있다.
어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.

이러한 의존성을 조금 더 세련된 단어로 표현한 것이 결합도이다.
두 요소가 의존성이 바람직할때를 느스한 결합도, 약한 결합도라 한다. 반대로, 두 요소 사이의 의존성이 바람직하지 못할때 단단한 결합도 또는 강한 결합도라고 표현한다

### 지식이 결합을 낳는다
더 구체화된 지식일 수록 강한 결합으로 연결된다.
Movie -> PercentDiscountPolicy (강결합)
Movie -> DiscountPolicy (느슨한 결합)

더 많이 알수록 더 많이 결합되는 구조이다. 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미하기 때문이다. 결합도를 느슨하기 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에 최대한 감추는 것이 중요하다.

이러한 목적을 달성하기 위해 가장 효과적인 방법이 *추상화*이다

### 추상화에 의존하라
추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다. 추상화를 이용하면 불필요한 정보를 감추고 지식의 양을 줄일 수 있다

PercentDiscountPolicy보다 DiscountPolicy가 지식의 양이 더 적다. Movie와 DiscountPolicy 사이의 결합도가 더 느스한 이유는 Movie가 구체적인 대상이 아닌 추상화에 의존하기 때문이다

* 구체 클래스
* 추상 클래스
* 인터페이스

클래스는 3개의 타입에 대하여 의존할 수 있다. 당연히 인터페이스와 의존 관계를 맺는 것이 느스한 결합을 만들어 준다

### 명시적인 의존성

아래의 코드를 살펴보며 의존성에 대한 문제를 찾아보자
[image:E6E803E7-F50B-4C75-A9E0-9B85AAB70BDD-879-000012B6F78A35AF/F8901DD7-253C-44AC-ADDC-ABDBA6B9A891.png]

New AmountDiscountPolicy가 결합도를 높이고 있다.

[image:9EACEEFC-31B7-43DF-B581-F3D15013D80B-879-000012C127AE3D04/BAF822DF-C934-4C9B-A82B-2ADD59AF516A.png]

명시적인 부분을 제거하여 결합도를 낮추어 주자. 이제 객체를 생성할 때 생성자의 인자로 DiscountPolicy의 어떠한 자식 클래스도 전달할 수 있다. 따라서, 런타임에 해당 인스턴스를 선택적으로 전달할 수 있게 되었다.

이처럼 의존하는 사실을 Public 인터페이스에 드러내는 것을 *명시적인 의존성*이라 한다. 반면, 내부에 AmountDiscountPolicy를 직접 생성하는 방식을 의존하는 사실은 감춘다고 하여 *숨겨진 의존성*이라 한다.

숨겨진 의존성의 경우 직접 코드 내부를 살펴보아야 하고, 인스턴스를 생성하는 코드를 훓어 파악해야 하므로 버그의 가능성도 내포하고 있다. 따라서, 우리는 재사용성을 높이고 안정성을 높이는 명시적인 의존성을 선택해야 한다.

### new는 해롭다
클래스는 인스턴스를 생성할 수 있게 new 연산자를 제공한다. 하지만 잘못 사용한다면 두 객체 사이의 결합도가 높아질 수 있다.

1. New 연산자로 구체 클래스 이름을 직접 기술한다.
2. 구체 클래스 뿐만 아니라, 어떠한 인자를 이용해 클래스를 생성할지 인자 정보도 알고 있어야 한다
   [image:AEEB8F1C-D938-464C-8781-0D18D25A8C8F-879-000013610325A31B/3A0BF018-FB59-4B8E-80F9-631DC9D605A9.png]

[image:EC6FA91C-417F-4E63-AC1E-BDDDA9BA6BA0-879-0000136771BD6F41/BAF822DF-C934-4C9B-A82B-2ADD59AF516A.png]

두개를 비교해보면 구체 클래스를 생성하는 것이 많은 고통을 유반한다는 것을 볼 수 있다

### 가끔은 생성해도 무방하다
new가 꼭 나쁜것만은 아니다. 생성되는 비율이 다를 경우 아래와 같이 여러 생성자를 이용하여 구현할 수 있다.

[image:2332699F-901E-48F8-BED3-948BE3382D7A-879-0000138D1F6360FA/DEADF90D-287D-40F8-8BBE-105DA0AFB9B5.png]

해당 생성자는 아래의 생성자를 호출하는 방식이다. 이런 방식으로 구현함으로써 유연성도 가져갈 수있따.

### 표준 클래스에 대한 의존은 해롭지 않다
의존성이 문제가 되었던 것은 변경 가능성으로 인해 유발되는 파생효과들이다.
다만, 표준 클래스처럼 변화가 거의 없는 것에 해당한다면 크게 문제될 것이 없다.

